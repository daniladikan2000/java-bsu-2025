# Banking System (Lab 2)

Реализация банковской системы транзакций на Java с использованием JDBC (H2 Database), многопоточности и паттернов проектирования.

---

### 1. Что такое UUID?
**UUID (Universally Unique Identifier)** — это стандарт идентификации, используемый в создании программного обеспечения. Это 128-битная метка (обычно представленная в виде строки из 32 шестнадцатеричных цифр, разделенных дефисами), которая гарантирует уникальность идентификатора в пространстве и времени без необходимости централизованного координатора.
В проекте используется класс `java.util.UUID` для генерации уникальных ID транзакций и пользователей.

### 2. Архитектура: User -> Список счетов
**Вопрос:** Является ли архитектура, где User хранит список своих счетов, нормальной? Предложите улучшения.
**Ответ:**
Честно говоря, архитектура, где `User` хранит внутри себя список `List<Account>`, — так себе решение для реальной жизни (хотя для лабы сойдет).
**Почему это плохо:**
1. Если мы удалим счет из базы, нам придется искать юзера, загружать его объект и чистить этот список вручную. Это лишняя работа.
2. Если у юзера 1000 счетов, мы каждый раз будем тянуть их из базы, даже если нам нужен только никнейм.

**Мое улучшение:**
Я сделал наоборот (как в нормальных SQL базах): в классе `Account` добавил поле `userUuid`. То есть не юзер знает про счета, а счет знает, чей он. Так гораздо проще искать и обновлять данные.

### 3. SOLID
* **S (Single Responsibility):** `AccountRepository` занимается ТОЛЬКО базой данных (SQL-запросы), а `TransactionProcessor` — только логикой потоков. Они не мешают друг другу.
* **O (Open/Closed):** (`DepositStrategy`, `WithdrawStrategy`...). Если потребуется добавить "Кредит", мне не надо переписывать весь `Processor` и ломать свитч-кейсы. Я просто создам новый класс `CreditStrategy`, и всё заработает само.
* **L (Liskov):** Везде, где используется интерфейс `TransactionStrategy`, я могу подставить любую его реализацию (хоть снятие, хоть заморозку), и программа не упадет.
* **I (Interface Segregation):** Я не стал пихать всё в один интерфейс. У меня отдельно `TransactionObserver` (для логов), отдельно `TransactionVisitor` (для отчетов).
* **D (Dependency Inversion):** В классе `TransactionProcessor` я не создаю `Repository` через `new`, а принимаю его через конструктор. Это позволяет легко подменить базу данных, если понадобится.

### 4. Паттерны проектирования
1. **Singleton:** `DatabaseConnection`. Чтобы подключение к базе было одно на всех и не плодились коннекты.
2. **Factory:** `TransactionFactory`. Помогает красиво создавать транзакции одной строчкой, без кучи `new Transaction(...)`.
3. **Strategy:** В зависимости от типа операции (DEPOSIT, FREEZE) подставляется нужный класс с логикой.
4. **Observer:** Логгер (`LoggingObserver`). Он "сидит и смотрит", когда транзакция закончится, чтобы написать в консоль. Процессору не надо самому писать в консоль.
5. **Visitor:** `TransactionReportVisitor`. Используется для генерации финального отчета. Он бегает по списку транзакций и собирает статистику.
6. **Command:** Связка "Транзакция + Процессор" работает как команда, которую мы кидаем в поток на выполнение.

### 5. Асинхронность и Многопоточность
**Вопрос:** Как сделать, чтобы миллион юзеров ничего не сломали? Какие паттерны и средства Java использовать?
**Ответ:**
Самое сложное — это **Race Condition** (гонка потоков). Это когда два потока одновременно пытаются снять деньги, читают один и тот же баланс, и в итоге списывается меньше, чем нужно.
Чтобы это решить, я использовал:
1. **`ExecutorService`** (Пул потоков) — чтобы не создавать миллион потоков (это положит сервер), а использовать, например, 8 рабочих потоков, которые разгребают очередь задач. Это паттерн **Producer-Consumer**.
2. **`ReentrantLock`** Внутри каждого `Account` у меня есть замок (`Lock`). Когда стратегия начинает работать со счетом, она делает `lock()`. Если другой поток тоже захочет тронуть этот счет, он "упрется" в замок и будет ждать. Это гарантирует **атомарность**.
3. **Concurrent Collections:** Использовал `CopyOnWriteArrayList` для списка наблюдателей, чтобы не ловить ошибки при многопоточной работе со списками.

P.S. JDBC подключил, H2 настроил так, чтобы таблицы сами создавались. Вроде всё работает!